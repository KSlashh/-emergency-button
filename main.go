package main

import (
	"context"
	"crypto/ecdsa"
	"flag"
	"fmt"
	"math"
	"math/big"
	"time"

	"github.com/KSlashh/migrate/abi"
	"github.com/KSlashh/migrate/config"
	"github.com/KSlashh/migrate/log"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
)

var DefaultGasLimit uint64 = 0 // get gas limit via EstimateGas
var gasMultipleDecimal int64 = 8
var network string
var keyConfigFile string
var confFile string
var standardizedConfigFile string
var multiple float64
var force bool
var all bool

func init() {
	flag.StringVar(&network, "network", "", "choose a network")
	flag.StringVar(&keyConfigFile, "key", "./keyConfig.json", "crypto key configuration file path")
	flag.StringVar(&confFile, "config", "./config.json", "business contract configuration file path")
	flag.StringVar(&standardizedConfigFile, "sconfig", "./sconfig.json", "config generated by hardhat deploy script")
	flag.Float64Var(&multiple, "mul", 1, "multiple of gasPrice, actual_gasPrice = suggested_gasPrice * mul ")
	flag.BoolVar(&force, "force", true, "need to force execute or not")
	flag.BoolVar(&all, "all", false, "update all network in config file")
	flag.Parse()
}

func main() {
	// merge config
	err := config.MergeConfig(standardizedConfigFile, confFile, force)
	if err != nil {
		log.Fatal(err)
	}

	// load config
	conf, err := config.LoadConfig(confFile)
	if err != nil {
		log.Fatal(err)
	}

	// load key config
	keys, err := config.LoadKeyConfig(keyConfigFile)
	if err != nil {
		log.Fatal(err)
	}

	if all {
		for i := 0; i < len(conf.Networks); i++ {
			err = updateNetwork(&conf.Networks[i], keys)
			if err != nil {
				log.Fatal(err)
			}
		}
	} else {
		err = updateNetwork(conf.GetNetwork(network), keys)
		if err != nil {
			log.Fatal(err)
		}
	}

}

func updateNetwork(network *config.Network, keys *config.KeyConfig) (err error) {
	client, err := ethclient.Dial(network.Provider)
	if err != nil {
		return
	}
	log.Infof("updating %s , new CCM address: %s", network.Name, network.NewCCMPAddress)
	for i := 0; i < len(network.BusinessContracts); i++ {
		err = update(client, network.BusinessContracts[i], network.NewCCMPAddress, keys)
		if err != nil {
			log.Errorf("update %s failed, ERROR: %s", network.BusinessContracts[i], err.Error())
			continue
		}
		log.Infof("contract %s has been updated", network.BusinessContracts[i])
	}
	return nil
}

func update(client *ethclient.Client, BusinessContractAddress common.Address, NewCCMPAddress common.Address, keys *config.KeyConfig) (err error) {
	BusinessContract, err := abi.NewBusinessContract(BusinessContractAddress, client)
	if err != nil {
		return
	}
	currentCCMP, err := BusinessContract.ManagerProxyContract(nil)
	if err != nil || currentCCMP == NewCCMPAddress {
		return fmt.Errorf("query current ccmp error: %s", err.Error())
	}
	owner, err := BusinessContract.Owner(nil)
	if err != nil {
		return fmt.Errorf("query owner error: %s", err.Error())
	}
	ownerKey := keys.GetKey(owner)
	privateKey, err := crypto.HexToECDSA(ownerKey.PrivateKey)
	if err != nil {
		return fmt.Errorf("import PrivateKey error: %s", err.Error())
	}
	chainId, err := client.ChainID(context.Background())
	if err != nil {
		return fmt.Errorf("get networkId error: %s", err.Error())
	}
	auth, err := MakeAuth(client, privateKey, DefaultGasLimit, multiple, chainId)
	if err != nil {
		return fmt.Errorf("makeAuth error: %s", err.Error())
	}
	tx, err := BusinessContract.SetManagerProxy(auth, NewCCMPAddress)
	if err != nil {
		return fmt.Errorf("setManagerProxy error: %s", err.Error())
	}
	return WaitTxConfirm(client, tx.Hash())
}

func MakeAuth(client *ethclient.Client, key *ecdsa.PrivateKey, gasLimit uint64, gasMultiple float64, chainId *big.Int) (*bind.TransactOpts, error) {
	authAddress := crypto.PubkeyToAddress(*key.Public().(*ecdsa.PublicKey))
	nonce, err := client.PendingNonceAt(context.Background(), authAddress)
	if err != nil {
		return nil, fmt.Errorf("makeAuth, addr %s, err %v", authAddress.Hex(), err)
	}

	gasPrice, err := client.SuggestGasPrice(context.Background())
	if err != nil {
		return nil, fmt.Errorf("makeAuth, get suggest gas price err: %v", err)
	}
	res := gasPrice.Mul(gasPrice, big.NewInt(int64(gasMultiple*math.Pow(10, float64(gasMultipleDecimal)))))
	if res == nil {
		return nil, fmt.Errorf("calculate actual gas price error (at mul")
	}
	res = gasPrice.Div(gasPrice, big.NewInt(int64(math.Pow(10, float64(gasMultipleDecimal)))))
	if res == nil {
		return nil, fmt.Errorf("calculate actual gas price error (at div")
	}

	// auth := bind.NewKeyedTransactor(key)
	auth, err := bind.NewKeyedTransactorWithChainID(key, chainId)
	if err != nil {
		return nil, fmt.Errorf("makeAuth, bind.NewKeyedTransactorWithChainID err: %v", err)
	}
	auth.From = authAddress
	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = big.NewInt(int64(0)) // in wei
	auth.GasLimit = gasLimit
	auth.GasPrice = gasPrice

	return auth, nil
}

func WaitTxConfirm(client *ethclient.Client, hash common.Hash) error {

	ticker := time.NewTicker(time.Second * 1)
	end := time.Now().Add(60 * time.Second)
	for now := range ticker.C {
		if now.After(end) {
			log.Info("Transaction pending for more than 1 min, check transaction %s on explorer yourself, make sure it's confirmed.", hash.Hex())
			break
		}
		_, pending, err := client.TransactionByHash(context.Background(), hash)
		if err != nil {
			log.Debug("failed to call TransactionByHash: %v", err)
			continue
		}
		if !pending {
			break
		}
		return nil
	}

	tx, err := client.TransactionReceipt(context.Background(), hash)
	if err != nil {
		return fmt.Errorf("faild to get receipt %s", hash.Hex())
	}

	if tx.Status == 0 {
		return fmt.Errorf("receipt failed %s", hash.Hex())
	}

	return nil
}
